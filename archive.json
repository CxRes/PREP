{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-10T00:57:50.274456+00:00",
  "repo": "CxRes/prep",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOKcksa85zaAKD",
      "title": "Handling Illegal `Accept-Events` Header",
      "url": "https://github.com/CxRes/prep/issues/1",
      "state": "OPEN",
      "author": "CxRes",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Where a recipient receives an illegal `Accept-Events` header field, can we:\r\n\r\n+ Ignore it (as we do now)?\r\n+ Send an error message. If so what could be the form of the error message?",
      "createdAt": "2023-10-10T20:45:10Z",
      "updatedAt": "2023-10-10T20:45:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOKcksa85zaDm5",
      "title": "Protocol identifier as a URL?",
      "url": "https://github.com/CxRes/prep/issues/2",
      "state": "OPEN",
      "author": "CxRes",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Can we a URL (in lieu of an identifier) to identify the notifications protocol?\r\n\r\nIf we use such a URL, can we obviate the need for an IANA registry for notifications protocol?",
      "createdAt": "2023-10-10T20:49:49Z",
      "updatedAt": "2023-10-10T20:49:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOKcksa85zaHJR",
      "title": "Handling response with notifications when not requested",
      "url": "https://github.com/CxRes/prep/issues/3",
      "state": "OPEN",
      "author": "CxRes",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Does compliance with HTTP demand that we ignore the `Events` header when sent in response to a request that does not contain an `Accept-Events` header? \r\n\r\nHow should the recipient process such a response, that presumably contains notifications that it has not requested?",
      "createdAt": "2023-10-10T20:54:04Z",
      "updatedAt": "2023-10-10T20:54:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOKcksa85zaMpD",
      "title": "Handling `Events` header for unsupported methods",
      "url": "https://github.com/CxRes/prep/issues/4",
      "state": "OPEN",
      "author": "CxRes",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Does the handling of  `Events` field need to be made more specific for unsupported/unrecognized methods?\r\n\r\nSuch as:\r\n\"A recipient MUST ignore the `Events` header field received in response to a request method that is unrecognized or for which notifications response is not defined for a particular notifications protocol.\"",
      "createdAt": "2023-10-10T21:02:49Z",
      "updatedAt": "2023-10-10T21:02:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOKcksa86Hggr7",
      "title": "Feedback on draft in `implementation` branch",
      "url": "https://github.com/CxRes/prep/issues/5",
      "state": "CLOSED",
      "author": "toomim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi! I just did a full read-through of the draft in the `implementation` branch, and took these notes. I'd be happy to talk 1-1, but in the meantime want to make them available to you, and this seemed like a reasonable place to put them. Feel free to close this issue or move them around however you'd like.\r\n\r\nFirst, congratulations on the draft progress! I can see it coming together, and it's shaping up to portray a very interesting approach on the problem.\r\n\r\nIn particular, I'm struck by the cool and intriguing use of multipart and message/rfc822.  I must admit that I don't fully understand them yet, but intrigued. I hope to understand them, and then understand what the advantages are of using them.\r\n\r\nNow, I think to move forward, it would be most excellent to achieve a connected understanding of how PREP and Braid are similar and different, so that we can work towards finding common language and headers for the things that are similar, and then for the parts that are different, either switch to using the same things, or create a modular option for the differences so that both can co-exist.\r\n\r\nTo get there, I still have some things I don't understand in PREP, and there are some parts that I have suggestions for improvements on. Here are my notes as I read PREP and work towards a common understanding. I think these might need a 1-1 conversation. Perhaps we can arrange that sometime \u2014 but I'm leaving the notes here in case it's useful!\r\n\r\nI'd like to start with you on these two sections of issues:\r\n\r\n**Accept-Events & Events:**\r\n\r\n - What are all the parameters available?\r\n   - What is `vary=` for?  How does it differ from Vary header in response?\r\n     - Example: `Events: ... vary=accept-encoding`\r\n   - What is `status=` for?  How does it differ from status in HTTP response?\r\n - What exactly is \"PREP\"?\r\n   - Doesn't PREP define Events and Accept-Events?  Or is it something within?\r\n   - Is `Events: protocol=PREP` the same as `Accept-Events: PREP`?\r\n   - What do you mean by \"protocol for receiving notifications\" in 4.1.?\r\n - Confused by recursion of:\r\n   - PREP: inside a field defined by PREP, in `Accept-Events: PREP; ` and `Events: protocol=PREP `\r\n     - if PREP defines the Events fields, what does it mean to say you're using PREP within your use of these PREP fields?\r\n   - Accept: the word \"accept\" appears twice within `Accept-Events: accept=message/rfc822`. Are we accepting what we accept?\r\n - What does it mean for a server to \"prefer\" a notification protocol?\r\n - It seems hard to use Accept-Events for improving performance without being\r\n   relied upon.  If you cannot rely upon it, then you cannot use it, right?\r\n   Am I missing something?  What can you rely upon vs. not rely upon?\r\n - Intro confused me with Accept-Events vs. Events -- distinction wasn't clear\r\n   - I suggest making Accept-Events optional and introducing later once core\r\n     concept is understood\r\n\r\n**Snapshots vs. Patches (or other terminology)**\r\n\r\n - Definitions:\r\n    - I'm calling a \"snapshot\" a complete copy of a the resource as seen at a point in time\r\n    - and \"patch\" a description of a change from the prior version to the current version, in whatever format.\r\n - This PREP draft makes a *snapshot* the first message, and then streams a sequence of patches, like this:\r\n   - `[ snapshot, [ patch, patch, patch, patch ] ]`\r\n - That's a common pattern, but this is more general and simpler:\r\n   - `[ snapshot-or-patch, snapshot-or-patch, snapshot-or-patch, snapshot-or-patch ]`\r\n - This would support\r\n   - systems that send a keyframe as a snapshot, and then send a series of diffs. Video works this way, as does `mosh` (I believe)\r\n   - systems where the server needs to periodically compute merges on behalf of the client. It can send all patches to the client, and then periodically send a full snapshot to clear up any ambiguities that occurred.\r\n\r\n...and then we could move on to discuss these smaller ones:\r\n\r\n**Time Representations**\r\n\r\n - These won't work for relative (distributed) time:\r\n   - Event-ID, Last-Event-ID, Etag, Date\r\n - So we also need `Version` (*c.f.* [Braid-HTTP](https://datatracker.ietf.org/doc/html/draft-toomim-httpbis-braid-http#section-2.1))\r\n - That adds up to including all these forms:\r\n   - `Event-ID`\r\n   - `Etag`\r\n   - `Date`\r\n   - `Version`\r\n - Are these all necessary?  Perhaps we could distinguish when each would be\r\n   needed, so that programmers don't have to fill out all 4 fields for each\r\n   version?\r\n\r\n**Multiparts**\r\n\r\n - As we've discussed, boundary specifiers can get clobbered, and I like your new multipart frame spec as a solution to that\r\n - I still don't see the need for multipart, myself, and prefer putting framing natively within HTTP messages rather than nesting multipart framing within bodies, but I am happy to work towards connection on this issue.\r\n\r\n**4.1.1. Validity**\r\n\r\n - The \"server must ignore fields it does not understand\" is already a part of\r\n   HTTP, and need not be repeated in so much detail here IMO.\r\n\r\n**5.1.  Event Fields**\r\n\r\n - What is an event field?\r\n   - It says that header fields can be event fields, but doesn't say what an\r\n     event field is.\r\n   - This sounds conusing, because there is an \"Event:\" \"header field\", but I\r\n     think that might be different from an \"Event Field\" as mentioned here.\r\n\r\n**Events vs. Patches?**\r\n\r\n - It seems that the concept of an \"Event\", since it can be arbitrarily\r\n   defined according to the event type, serves the same semantic purpose in\r\n   mutating a resource as the PATCH method in HTTP.  Is that true?  Or is\r\n   there a distinction?\r\n\r\n**What is DPoP in the example in section 7?**\r\n\r\n**Deltas**\r\n\r\n - What precisely do you mean by a delta here?  Do you mean the delta\r\n   mentioned in [delta], do you mean an arbitrary patch e.g. as used in a HTTP\r\n   PATCH method?  Or something else, or more general?\r\n\r\n - Would help if the example gave a concrete delta instead of the placeholder <delta>",
      "createdAt": "2024-05-01T12:43:26Z",
      "updatedAt": "2024-07-27T06:09:44Z",
      "closedAt": "2024-07-27T06:08:38Z",
      "comments": [
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "Thanks for the review and your thoughts! I had privately communicated to you, all the way back in early May, the personal circumstances that prevented me from posting a response sooner.\r\n\r\nDue to the number of questions you have raised here, and in the spirit of notifications, this is going to be a multipart response. I will indeed rearrange some issues, and I hope this will bring structure to our shared understanding of notifications. Please wait for me to complete these responses, after which I shall close this issue. Unless you have a very general remark, I would request you to start new issue(s) for responses or further questions on a particular comment, linking back to the comment here.",
          "createdAt": "2024-07-27T05:08:02Z",
          "updatedAt": "2024-07-27T05:08:02Z"
        },
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "## Accept-Events & Events Header Fields\r\n\r\nThe `Accept-Events` & `Events` header fields build on the well established negotiation pattern of `Accept(-*)` and `Content-*` headers. Just as the `Accept` header field is used to request a preferred media-type and server responds with the `Content-Type` header field indicating the media-type it is serving, the `Accept-Events` header field is used to request a preferred notifications protocol and server responds with the `Events` header field indicating the notification protocol it is using to serve notifications. Just as `Accept` in the response provides a list of media-types it can serve in the future,  `Accept-Events` in a response provides the list of supported notification protocols for subsequent requests.\r\n\r\nSuch content negotiation serves many useful purposes:\r\n\r\n+ The `Events` header field tell a recipient, if the `GET` response semantics have been modified to send notifications.\r\n+ Client is able to request different protocols, obviously.\r\n  + This helps facilitate the switch from one protocol to another without the need to invent still new headers and/or other mechanism into HTTP. This will be useful for backwards compatibility and transitioning when new protocols come about.\r\n  + Rather than having only a general purpose protocol, it might be the case that a specialized protocol might be preferred by a consumer when the representation is of a particular (set of) media-type. For example, there is an emerging case in Solid where notifications for RDF resources are served with an infinite turtle or n3 file.\r\n+ Clients are able to parametrize notification requests via the `Accept-Events` header field, and the server is able to indicate the parameters it honoured via the `Events` header field.\r\n\r\nTo your specific questions:\r\n\r\n<br>\r\n\r\n> + What are all the parameters available?\r\n\r\n_For Headers:_\r\n\r\nFrom 4.1.2 (Emphasis mine)\r\n\r\nA protocol identifier MAY be followed with zero or more parameters _defined by the given protocol_, which MAY be followed by a q parameter.\r\n\r\n&\r\n\r\nFrom 4.2.2 (Emphasis mine)\r\n\r\nIt MUST contain one member with the key protocol whose value identifies the notification protocol used in the response. It MAY contain other members that are _defined by the given notification protocol_.\r\n\r\n_For PREP:_\r\n\r\nSection 5.1\r\n\r\nThe Per Resource Events Protocol reuses existing HTTP fields ([HTTP], Section 5) as event fields. Any HTTP field MAY be used as an event field. For the limited context of notifications using the Per Resource Events Protocol, an event field with the same name as an HTTP field MUST have identical semantics to that HTTP field, unless otherwise specified.\r\n\r\n<br>\r\n\r\n> + ...\r\n>     + What is `vary=` for? How does it differ from Vary header in response?\r\n>          + Example: `Events: ... vary=accept-encoding`\r\n\r\nThe client is allowed to specify parameters along with their choice of protocols. For example:\r\n\r\n```\r\nAccept-Events: \"prep\"; accept=\"text/turtle\"\r\n```\r\n\r\nsays, use PREP for notifications, but use `text/turtle` as the format for a notification.\r\n\r\nIn which case, the response `Events` header might say:\r\n\r\n```\r\nEvents: protocol=\"prep\"; status=200; vary=\"accept\"\r\n```\r\n\r\nmeaning that server understood the request and will `vary` the content-type of the notification as requested by the client.\r\n\r\nIf the `vary` did not include `accept`, that would mean the server will not vary the notification media-type and use the default `message/rfc822` format.\r\n\r\nThis is consistent with reusing a header field as an event field.\r\n\r\n<br>\r\n\r\n> + ...\r\n>     + What is `status=` for? How does it differ from status in HTTP response?\r\n\r\n`status` in the `Events` header field indicates the status for the notifications (portion of the response). For example, a server may present 200 status code for the response as a whole but a 5xx status in the `Events` header, if it is able to serve the current representation but not notifications.\r\n\r\n<br>\r\n\r\n> + What exactly is \"PREP\"?\r\n>     + Doesn't PREP define Events and Accept-Events? Or is it something within?\r\n\r\nPREP, the specification defines `Accept-Events` and `Events` header fields, the Per Resource Events Protocol (also PREP) and Semantics for `message/rfc822` when used with the Per Resource Events Protocol.\r\n\r\nIt is not uncommon or unnatural for a specification to define supporting its infrastructure, especially in the initial versions. Based on community feedback, these can always be split out into three separate documents.\r\n\r\n<br>\r\n\r\n> + ...\r\n>   + Is `Events: protocol=PREP` the same as `Accept-Events: PREP`?\r\n\r\nNo. See above for detailed explanation above.\r\n\r\n<br>\r\n\r\n> + ...\r\n>   + What do you mean by \"protocol for receiving notifications\" in 4.1.\r\n\r\nThe phrase has been picked out of context. The entire sentence is:\r\n\r\n\"The Accept-Events header field can be used by application clients to specify their preferred protocol for receiving notifications.\"\r\n\r\nwhich is quite self-explanatory.\r\n\r\n<br>\r\n\r\n> + Confused by recursion of:\r\n>   + PREP: inside a field defined by PREP, in `Accept-Events: PREP`;  and `Events: protocol=PREP`\r\n>      + if PREP defines the Events fields, what does it mean to say you're using PREP within your use of these PREP fields?\r\n\r\nThis feels like a repeat of the previous question! It is not unheard of to use a proper noun to refer to two related things based on the context of use.\r\n\r\nThere are no \"PREP fields\". Perhaps you mean event fields. Saying `Events: protocol=\"prep\"` means that response will send notifications using the Per Resource Events protocol.\r\n\r\n<br>\r\n\r\n> + ...\r\n>     + Accept: the word \"accept\" appears twice within `Accept-Events: accept=message/rfc822`. Are we accepting what we accept?\r\n\r\nThe example cited here is copied over incorrectly, rendering the question meaningless. The correct example is:\r\n\r\n```\r\nAccept-Events: \"prep\"; accept=message/rfc822\r\n```\r\n\r\nHere, the client is asking the server to use \"prep\" as a notifications protocol and deliver any notification using the \"message/rfc822\" media type.\r\n\r\nWhy-o-why is it so hard to accept, that reusing the same word twice is acceptable?\r\n\r\n<br>\r\n\r\n> + What does it mean for a server to \"prefer\" a notification protocol?\r\n\r\nI am not sure where you have picked that from. The client indicates a preference for a protocol in the request, and the server might fulfil it. A server can also provide a list of protocols for the client to \"prefer\" from.\r\n\r\n<br>\r\n\r\n> + It seems hard to use Accept-Events for improving performance without being\r\n> relied upon. If you cannot rely upon it, then you cannot use it, right?\r\n> Am I missing something? What can you rely upon vs. not rely upon?\r\n\r\nI do not quite follow what you even mean by \"rely upon\"? This is not different from being able to \"rely upon\" any other HTTP header field?\r\n\r\n<br>\r\n\r\n> + Intro confused me with Accept-Events vs. Events -- distinction wasn't clear\r\n>    + I suggest making Accept-Events optional and introducing later once core\r\nconcept is understood.\r\n\r\nAs I have established above, the `Accept-Events` and `Events` header fields are based on the well established negotiation pattern defined in the HTTP protocol. I have motivated above the reasons why such a pattern is useful. Perhaps for these reasons, the ability to negotiate notification protocols has also found support with other members in the community.\r\n\r\nIf the objection is to the language itself, I'll take that as an editorial comment!\r\n\r\n\r\n## Event Fields\r\n\r\n> **5.1. Event Fields**\r\n>\r\n> + What is an event field?\r\n>     + It says that header fields can be event fields, but doesn't say what an\r\n>     event field is.\r\n>     + This sounds conusing, because there is an \"Event:\" \"header field\", but I\r\n>     think that might be different from an \"Event Field\" as mentioned here.\r\n\r\n**Defined in section 3.5 Terminology**.\r\n\r\n\"Event Field\r\nA parameter for a protocol item in the [Accept-Events](https://cxres.github.io/prep/draft-gupta-httpbis-per-resource-events.html#accept-events-header) header field or a member of the [Events](https://cxres.github.io/prep/draft-gupta-httpbis-per-resource-events.html#events-header) header field.\"\r\n\r\nIf you click on any instance of the word \"event field\" in the HTML or PDF versions of the spec, it will take you to this definition.",
          "createdAt": "2024-07-27T05:20:50Z",
          "updatedAt": "2024-07-27T05:51:33Z"
        },
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "## Resource, Representation and Notification\r\n\r\n> Definitions:\r\n> + I'm calling a \"snapshot\" a complete copy of a the resource as seen at a point in time and \"patch\" a description of a change from the prior version to the current version, in whatever format.\r\n\r\nThe resource is by definition an abstract object. There is no way to truly copy a HTTP resource. A HTTP request provides you a representation of the state of the resource, which may or may not be bit-identical to how the server maintains information associated to that resource (assuming the resource is stored as a digital entity, which is not necessarily true).\r\n\r\nWhen tracking the evolution of a resource over time, a server needs to provide a representation of an event (events being space-time equivalent of state in space, in HTTP terms, a method) on the resource. This is what I call a notification.\r\n\r\nThis could be a patch applied to a representation (of state), but need not be. A simpler notification could just inform a user-agent of an event or provide metadata about the event.\r\n\r\nThus, a HTTP message in PREP has the pattern:\r\n[ representation, [ notification, notification, notification, notification ] ]\r\n\r\n<br>\r\n\r\n> + This PREP draft makes a snapshot the first message, and then streams a sequence of patches, like this:\r\n[ snapshot, [ patch, patch, patch, patch ] ]\r\n> + That's a common pattern, but this is more general and simpler:\r\n[ snapshot-or-patch, snapshot-or-patch, snapshot-or-patch, snapshot-or-patch ]\r\n\r\nThis is an artefact of using multipart according to the guidance of RFC2046, Section 5.1.5., Paragraph 2. If we were to find different composite media-types (see discussion below), I would have no objection to using a flat structure.",
          "createdAt": "2024-07-27T05:25:03Z",
          "updatedAt": "2024-07-27T05:25:03Z"
        },
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "## Notifications Framing\r\n\r\n(or why I went with `multipart/*` as the composite media-type for serving notifications)\r\n\r\nA message communicated over HTTP is, explicitly or implicitly, required to have a media-type. I am aware of only two general purpose composite media types that do not require the content structure to be known in advance:\r\n\r\n1. multipart/*\r\n2. application/http\r\n\r\nPerhaps the second is more to your liking. I have tried my level best to obtain more information about the second, to little avail. In particular, I have not been able to find any real-world usage examples.\r\n\r\nWhereas, `multipart/*` is much more well established, is the preferred media type for composite messages in HTTP (`multipart/byterange` and `multipart/form-data`) and information about it was much easier to find.\r\n\r\n### Multipart boundary\r\n\r\n> As we've discussed, boundary specifiers can get clobbered, and I like your new multipart frame spec as a solution to that\r\n\r\nIf the boundary delimiter has high entropy, for all practical purposes, the boundary strings will never clobber. There are more boundary strings available than there are atoms in the known universe.\r\n\r\nIn [Express PREP](https://github.com/CxRes/express-prep/), we are able to quite easily provide unique boundaries for each response stream, even when they are transmitting the same notifications at no significant processing cost.\r\n\r\nAnd if someone manages to get hold of your stream's unique boundary and inject it back, you have much bigger problems at that time, my friend! And this will affect only the one subscriber who has been attacked.\r\n\r\nWhile I would like a boundary less composite media-type as well (not because of the infinitesimal possibility of clobbering, but due to the general simplicity of the middleware). The \"Multipart without Boundaries\" proposal was not workable, as pointed out by folks at mediaman.\r\n\r\n### Native Framing\r\n\r\n> I still don't see the need for multipart, myself, and prefer putting framing natively within HTTP messages rather than nesting multipart framing within bodies\r\n\r\nI have previously discussed with you at length why I cannot agree with this statement. HTTP Semantics does not provide a mechanism, as of now, for natively putting multiple messages in a single HTTP response, except using composite media-types.\r\n\r\nThe \"104 MultiResponse\" proposal is unfortunately a non-starter, because RFC9110 only allows for a final response (>=200) after 1xx responses (which only have headers and no bodies). Consequently, this can be used to communicate only one representation/notification.\r\n\r\nThe \"709 Subscription\" proposal by K\u00e9vin Dunglas (Mercure) is perhaps more viable, but that would require a definition of a new class of status codes that currently do not exist, which is likely to break existing HTTP implementations.\r\n\r\nThe logical extension of these two proposals would be to rewrite HTTP Semantics to support resources in both space and time. But that is quite an onerous task, when simpler options are available that we can deploy today.\r\n\r\n### Open to options\r\n\r\nIf another composite media-type comes to my attention or a native framing strategy is ever adopted by HTTP, I am happy to assess those options for notifications.\r\n\r\nIf an option is not immediately forthcoming, the benefit of having negotiation (see above) is that we can easily switch to another notification protocol that we invent at a later date.",
          "createdAt": "2024-07-27T05:44:57Z",
          "updatedAt": "2024-07-27T05:44:57Z"
        },
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "## Time Representations\r\n\r\n> + These won't work for relative (distributed) time:\r\n>     + Event-ID, Last-Event-ID, Etag, Date\r\n> + So we also need Version (c.f. [Braid-HTTP](https://datatracker.ietf.org/doc/html/draft-toomim-httpbis-braid-http#section-2.1))\r\n\r\nPhysics tells me that `Event-ID` will work! Because a state, that you wish to identify with a `Version`, is an outcome of some event. Having said that, I have no objections to using `Version`.\r\n\r\nFor the last two, see immediately below.\r\n\r\n<br>\r\n\r\n> Are these all necessary? Perhaps we could distinguish when each would be\r\n> needed, so that programmers don't have to fill out all 4 fields for each\r\n> version?\r\n\r\nThe use of any one strategy to identify a representation (or a corresponding state) does not preclude another. We need not even assume that every HTTP server will use versions, even if that would be ideal.\r\n\r\n`ETag` is widely deployed and useful, especially for systems not using versioning. A lot of systems already return an E-Tag. Explicitly disallowing it seems too forceful. And it seems even more strange to leave out `Date`. A server can always choose what it wants to fill out.",
          "createdAt": "2024-07-27T06:01:29Z",
          "updatedAt": "2024-07-27T06:01:29Z"
        },
        {
          "author": "CxRes",
          "authorAssociation": "OWNER",
          "body": "## Misc.\r\n\r\n> **4.1.1. Validity**\r\n>\r\n> The \"server must ignore fields it does not understand\" is already a part of\r\n> HTTP, and need not be repeated in so much detail here IMO.\r\n\r\nI'll take that comment as editorial.\r\n\r\n<br>\r\n\r\n> **What is DPoP in the example in section 7?**\r\n\r\nIt is an authentication token [RFC9449: OAuth 2.0 Demonstrating Proof of Possession (DPoP)] carried over from a real-world PREP example. Removed in draft-01 as it is extraneous to the specification!\r\n\r\n<br>\r\n\r\n> **Deltas**\r\n>\r\n> What precisely do you mean by a delta here? Do you mean the delta\r\n> mentioned in [delta], do you mean an arbitrary patch e.g. as used in a HTTP\r\n> PATCH method? Or something else, or more general?\r\n\r\nThe ambiguity is somewhat intentional. My intention was to allow servers to support different delta strategies, whether that's RFC3229 or PATCH or yet another. I may change my stance with sufficient implementation feedback!",
          "createdAt": "2024-07-27T06:08:38Z",
          "updatedAt": "2024-07-27T06:09:44Z"
        }
      ]
    }
  ],
  "pulls": []
}